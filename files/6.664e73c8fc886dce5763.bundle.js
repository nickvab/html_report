(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{2567:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"FilesystemWeb",(function(){return FilesystemWeb}));var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(122),_definitions__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(1050);function resolve(path){const posix=path.split("/").filter(item=>"."!==item),newPosix=[];return posix.forEach(item=>{".."===item&&newPosix.length>0&&".."!==newPosix[newPosix.length-1]?newPosix.pop():newPosix.push(item)}),newPosix.join("/")}class FilesystemWeb extends _capacitor_core__WEBPACK_IMPORTED_MODULE_0__.d{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async options=>{var _a,_b;const requestInit=Object(_capacitor_core__WEBPACK_IMPORTED_MODULE_0__.e)(options,options.webFetchExtra),response=await fetch(options.url,requestInit);let blob;if(options.progress)if(null==response?void 0:response.body){const reader=response.body.getReader();let bytes=0;const chunks=[],contentType=response.headers.get("content-type"),contentLength=parseInt(response.headers.get("content-length")||"0",10);for(;;){const{done:done,value:value}=await reader.read();if(done)break;chunks.push(value),bytes+=(null==value?void 0:value.length)||0;const status={url:options.url,bytes:bytes,contentLength:contentLength};this.notifyListeners("progress",status)}const allChunks=new Uint8Array(bytes);let position=0;for(const chunk of chunks)void 0!==chunk&&(allChunks.set(chunk,position),position+=chunk.length);blob=new Blob([allChunks.buffer],{type:contentType||void 0})}else blob=new Blob;else blob=await response.blob();return{path:(await this.writeFile({path:options.path,directory:null!==(_a=options.directory)&&void 0!==_a?_a:void 0,recursive:null!==(_b=options.recursive)&&void 0!==_b&&_b,data:blob})).uri,blob:blob}}}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((resolve,reject)=>{const request=indexedDB.open(this.DB_NAME,this.DB_VERSION);request.onupgradeneeded=FilesystemWeb.doUpgrade,request.onsuccess=()=>{this._db=request.result,resolve(request.result)},request.onerror=()=>reject(request.error),request.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(event){const db=event.target.result;switch(event.oldVersion){case 0:case 1:default:db.objectStoreNames.contains("FileStorage")&&db.deleteObjectStore("FileStorage");db.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}}async dbRequest(cmd,args){const readFlag=-1!==this._writeCmds.indexOf(cmd)?"readwrite":"readonly";return this.initDb().then(conn=>new Promise((resolve,reject)=>{const req=conn.transaction(["FileStorage"],readFlag).objectStore("FileStorage")[cmd](...args);req.onsuccess=()=>resolve(req.result),req.onerror=()=>reject(req.error)}))}async dbIndexRequest(indexName,cmd,args){const readFlag=-1!==this._writeCmds.indexOf(cmd)?"readwrite":"readonly";return this.initDb().then(conn=>new Promise((resolve,reject)=>{const req=conn.transaction(["FileStorage"],readFlag).objectStore("FileStorage").index(indexName)[cmd](...args);req.onsuccess=()=>resolve(req.result),req.onerror=()=>reject(req.error)}))}getPath(directory,uriPath){const cleanedUriPath=void 0!==uriPath?uriPath.replace(/^[/]+|[/]+$/g,""):"";let fsPath="";return void 0!==directory&&(fsPath+="/"+directory),""!==uriPath&&(fsPath+="/"+cleanedUriPath),fsPath}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(options){const path=this.getPath(options.directory,options.path),entry=await this.dbRequest("get",[path]);if(void 0===entry)throw Error("File does not exist.");return{data:entry.content?entry.content:""}}async writeFile(options){const path=this.getPath(options.directory,options.path);let data=options.data;const encoding=options.encoding,doRecursive=options.recursive,occupiedEntry=await this.dbRequest("get",[path]);if(occupiedEntry&&"directory"===occupiedEntry.type)throw Error("The supplied path is a directory.");const parentPath=path.substr(0,path.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[parentPath])){const subDirIndex=parentPath.indexOf("/",1);if(-1!==subDirIndex){const parentArgPath=parentPath.substr(subDirIndex);await this.mkdir({path:parentArgPath,directory:options.directory,recursive:doRecursive})}}if(!(encoding||data instanceof Blob||(data=data.indexOf(",")>=0?data.split(",")[1]:data,this.isBase64String(data))))throw Error("The supplied data is not valid base64 content.");const now=Date.now(),pathObj={path:path,folder:parentPath,type:"file",size:data instanceof Blob?data.size:data.length,ctime:now,mtime:now,content:data};return await this.dbRequest("put",[pathObj]),{uri:pathObj.path}}async appendFile(options){const path=this.getPath(options.directory,options.path);let data=options.data;const encoding=options.encoding,parentPath=path.substr(0,path.lastIndexOf("/")),now=Date.now();let ctime=now;const occupiedEntry=await this.dbRequest("get",[path]);if(occupiedEntry&&"directory"===occupiedEntry.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[parentPath])){const subDirIndex=parentPath.indexOf("/",1);if(-1!==subDirIndex){const parentArgPath=parentPath.substr(subDirIndex);await this.mkdir({path:parentArgPath,directory:options.directory,recursive:!0})}}if(!encoding&&!this.isBase64String(data))throw Error("The supplied data is not valid base64 content.");if(void 0!==occupiedEntry){if(occupiedEntry.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");data=void 0===occupiedEntry.content||encoding?occupiedEntry.content+data:btoa(atob(occupiedEntry.content)+atob(data)),ctime=occupiedEntry.ctime}const pathObj={path:path,folder:parentPath,type:"file",size:data.length,ctime:ctime,mtime:now,content:data};await this.dbRequest("put",[pathObj])}async deleteFile(options){const path=this.getPath(options.directory,options.path);if(void 0===await this.dbRequest("get",[path]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(path)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[path])}async mkdir(options){const path=this.getPath(options.directory,options.path),doRecursive=options.recursive,parentPath=path.substr(0,path.lastIndexOf("/")),depth=(path.match(/\//g)||[]).length,parentEntry=await this.dbRequest("get",[parentPath]),occupiedEntry=await this.dbRequest("get",[path]);if(1===depth)throw Error("Cannot create Root directory");if(void 0!==occupiedEntry)throw Error("Current directory does already exist.");if(!doRecursive&&2!==depth&&void 0===parentEntry)throw Error("Parent directory must exist");if(doRecursive&&2!==depth&&void 0===parentEntry){const parentArgPath=parentPath.substr(parentPath.indexOf("/",1));await this.mkdir({path:parentArgPath,directory:options.directory,recursive:doRecursive})}const now=Date.now(),pathObj={path:path,folder:parentPath,type:"directory",size:0,ctime:now,mtime:now};await this.dbRequest("put",[pathObj])}async rmdir(options){const{path:path,directory:directory,recursive:recursive}=options,fullPath=this.getPath(directory,path),entry=await this.dbRequest("get",[fullPath]);if(void 0===entry)throw Error("Folder does not exist.");if("directory"!==entry.type)throw Error("Requested path is not a directory");const readDirResult=await this.readdir({path:path,directory:directory});if(0!==readDirResult.files.length&&!recursive)throw Error("Folder is not empty");for(const entry of readDirResult.files){const entryPath=`${path}/${entry.name}`;"file"===(await this.stat({path:entryPath,directory:directory})).type?await this.deleteFile({path:entryPath,directory:directory}):await this.rmdir({path:entryPath,directory:directory,recursive:recursive})}await this.dbRequest("delete",[fullPath])}async readdir(options){const path=this.getPath(options.directory,options.path),entry=await this.dbRequest("get",[path]);if(""!==options.path&&void 0===entry)throw Error("Folder does not exist.");const entries=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(path)]);return{files:await Promise.all(entries.map(async e=>{let subEntry=await this.dbRequest("get",[e]);return void 0===subEntry&&(subEntry=await this.dbRequest("get",[e+"/"])),{name:e.substring(path.length+1),type:subEntry.type,size:subEntry.size,ctime:subEntry.ctime,mtime:subEntry.mtime,uri:subEntry.path}}))}}async getUri(options){const path=this.getPath(options.directory,options.path);let entry=await this.dbRequest("get",[path]);return void 0===entry&&(entry=await this.dbRequest("get",[path+"/"])),{uri:(null==entry?void 0:entry.path)||path}}async stat(options){const path=this.getPath(options.directory,options.path);let entry=await this.dbRequest("get",[path]);if(void 0===entry&&(entry=await this.dbRequest("get",[path+"/"])),void 0===entry)throw Error("Entry does not exist.");return{type:entry.type,size:entry.size,ctime:entry.ctime,mtime:entry.mtime,uri:entry.path}}async rename(options){await this._copy(options,!0)}async copy(options){return this._copy(options,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(options,doRename=!1){let{toDirectory:toDirectory}=options;const{to:to,from:from,directory:fromDirectory}=options;if(!to||!from)throw Error("Both to and from must be provided");toDirectory||(toDirectory=fromDirectory);const fromPath=this.getPath(fromDirectory,from),toPath=this.getPath(toDirectory,to);if(fromPath===toPath)return{uri:toPath};if(function isPathParent(parent,children){parent=resolve(parent),children=resolve(children);const pathsA=parent.split("/"),pathsB=children.split("/");return parent!==children&&pathsA.every((value,index)=>value===pathsB[index])}(fromPath,toPath))throw Error("To path cannot contain the from path");let toObj;try{toObj=await this.stat({path:to,directory:toDirectory})}catch(e){const toPathComponents=to.split("/");toPathComponents.pop();const toPath=toPathComponents.join("/");if(toPathComponents.length>0){if("directory"!==(await this.stat({path:toPath,directory:toDirectory})).type)throw new Error("Parent directory of the to path is a file")}}if(toObj&&"directory"===toObj.type)throw new Error("Cannot overwrite a directory with a file");const fromObj=await this.stat({path:from,directory:fromDirectory}),updateTime=async(path,ctime,mtime)=>{const fullPath=this.getPath(toDirectory,path),entry=await this.dbRequest("get",[fullPath]);entry.ctime=ctime,entry.mtime=mtime,await this.dbRequest("put",[entry])},ctime=fromObj.ctime?fromObj.ctime:Date.now();switch(fromObj.type){case"file":{const file=await this.readFile({path:from,directory:fromDirectory});let encoding;doRename&&await this.deleteFile({path:from,directory:fromDirectory}),file.data instanceof Blob||this.isBase64String(file.data)||(encoding=_definitions__WEBPACK_IMPORTED_MODULE_1__.b.UTF8);const writeResult=await this.writeFile({path:to,directory:toDirectory,data:file.data,encoding:encoding});return doRename&&await updateTime(to,ctime,fromObj.mtime),writeResult}case"directory":{if(toObj)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:to,directory:toDirectory,recursive:!1}),doRename&&await updateTime(to,ctime,fromObj.mtime)}catch(e){}const contents=(await this.readdir({path:from,directory:fromDirectory})).files;for(const filename of contents)await this._copy({from:`${from}/${filename.name}`,to:`${to}/${filename.name}`,directory:fromDirectory,toDirectory:toDirectory},doRename);doRename&&await this.rmdir({path:from,directory:fromDirectory})}}return{uri:toPath}}isBase64String(str){try{return btoa(atob(str))==str}catch(err){return!1}}}FilesystemWeb._debug=!0}}]);
//# sourceMappingURL=6.664e73c8fc886dce5763.bundle.js.map